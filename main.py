# backend/main.py
from flask import Flask, request, send_file, jsonify
import os
import uuid
import subprocess
import urllib.request

import time


import re
import json as json_lib

import openai

import glob
import random

from openai_utils import log_openai_request

import threading  # üëà for async job handling

   

# üîΩ Download soundfont if it's missing
SOUNDFONT_FILE = "FluidR3_GM.sf2"
SOUNDFONT_URL = "https://drive.google.com/uc?export=download&id=1mxi3Sa2t2hUqQ50hBw1BKGffPzSlIplD"

if not os.path.exists(SOUNDFONT_FILE):
    print("üéµ Downloading FluidR3_GM.sf2...")
    try:
        urllib.request.urlretrieve(SOUNDFONT_URL, SOUNDFONT_FILE)
        print("‚úÖ SoundFont downloaded successfully.")
    except Exception as e:
        print(f"‚ùå Failed to download SoundFont: {e}")



app = Flask(__name__)

# ‚úÖ In-memory job store
jobs = {}




# ‚úÖ Configuration
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
OUTPUT_DIR = os.path.join(BASE_DIR, "output")
SOUNDFONT_PATH = os.path.join(BASE_DIR, "FluidR3_GM.sf2")
MIN_FILE_SIZE = 10  # bytes



JOBS_FILE = os.path.join(BASE_DIR, "jobs.json")


BALANCES_FILE = os.path.join(BASE_DIR, "balances.json")

def load_balances():
    if os.path.exists(BALANCES_FILE):
        with open(BALANCES_FILE, "r") as f:
            return json_lib.load(f)
    return {}

def save_balances(balances):
    with open(BALANCES_FILE, "w") as f:
        json_lib.dump(balances, f)


import threading
balance_lock = threading.Lock()

def update_balance(user_id, delta):
    """
    Safely updates the user's balance by `delta` (can be positive or negative).
    Automatically loads and saves the balances with thread locking.
    Returns the new balance.
    """
    with balance_lock:
        balances = load_balances()
        new_balance = round(balances.get(user_id, 0.0) + delta, 2)
        balances[user_id] = new_balance
        save_balances(balances)

        # ‚úÖ log it
        reason = "credit" if delta > 0 else "job deduction"
        log_balance_change(user_id, delta, reason)

        return new_balance



BALANCE_LOG_FILE = os.path.join(BASE_DIR, "balance_log.jsonl")

def log_balance_change(user_id, delta, reason):
    with open(BALANCE_LOG_FILE, "a") as f:
        json_lib.dump({
            "timestamp": int(time.time()),
            "user_id": user_id,
            "change": delta,
            "reason": reason
        }, f)
        f.write("\n")



def add_footer_to_lilypond(code):
    footer = r"""
\paper {
  left-margin = 25\mm
  line-width = 170\mm
  oddFooterMarkup = \markup {
    \column {
      \fill-line {
        \tiny \italic "Generated by Lyrena"
      }
    }
  }
}
"""
    return code.strip() + "\n\n" + footer.strip()
    
    
import re
def extract_title_from_lilypond(code):
    match = re.search(r'title\s*=\s*"([^"]+)"', code)
    return match.group(1) if match else "Untitled"



def save_jobs_to_file():
    try:
        with open(JOBS_FILE, "w") as f:
            json_lib.dump(jobs, f)
    except Exception as e:
        print(f"‚ùå Failed to save jobs: {e}")

def load_jobs_from_file():
    global jobs
    try:
        if os.path.exists(JOBS_FILE):
            with open(JOBS_FILE, "r") as f:
                jobs = json_lib.load(f)
                print(f"üîÑ Loaded {len(jobs)} jobs from disk")
    except Exception as e:
        print(f"‚ùå Failed to load jobs: {e}")

load_jobs_from_file()


# ‚úÖ Ensure output/ exists
if not os.path.exists(OUTPUT_DIR):
    os.makedirs(OUTPUT_DIR)
    
    

@app.route("/user-balance", methods=["GET"])
def get_user_balance():
    user_id = request.args.get("user_id")
    if not user_id:
        return jsonify({"error": "Missing user_id"}), 400
    balance = get_user_balance_value(user_id)
    return jsonify({"user_id": user_id, "balance": balance})

    
    
def get_user_balance_value(user_id):
    """
    Thread-safe read of the user's current balance from disk.
    """
    with balance_lock:
        balances = load_balances()
        return round(balances.get(user_id, 0.0), 2)


@app.route("/add-credits", methods=["POST"])
def add_credits():

    data = request.get_json()
    user_id = data.get("user_id")
    amount = float(data.get("amount", 0))

    if not user_id or amount <= 0:
        return jsonify({"error": "Missing user_id or invalid amount"}), 400

    new_balance = update_balance(user_id, amount)
    return jsonify({"user_id": user_id, "balance": new_balance})





@app.route("/job-status/<job_id>")
def job_status(job_id):
    job = jobs.get(job_id)
    if not job:
        return jsonify({"error": "Job not found"}), 404
    return jsonify(job)



@app.route("/download/<filename>")
def download(filename):
    path = os.path.join(OUTPUT_DIR, filename)
    if os.path.exists(path) and os.path.getsize(path) > MIN_FILE_SIZE:
        print(f"üì§ Sending: {filename}")
        return send_file(path)
    print(f"‚ùå Missing or invalid file: {filename}")
    return jsonify({"error": "File missing or invalid"}), 500



openai.api_key = os.environ.get("OPENAI_API_KEY")




def run_smart_generation(user_prompt, model, balance):
    import re
    import json as json_lib
    import glob
    import random
    from openai_utils import log_openai_request

    if balance < 0.99:
        raise ValueError("Insufficient funds")

    NUM_ITERATIONS = 1

    EXAMPLE_SCORES_DIR = os.path.join(BASE_DIR, "example_scores")
    example_files = glob.glob(os.path.join(EXAMPLE_SCORES_DIR, "example_score_*.ly"))
    if not example_files:
        raise RuntimeError("No example_score_*.ly files found")

    random_example_path = random.choice(example_files)
    with open(random_example_path, "r", encoding="utf-8") as f:
        example_lilypond = f.read()

    conversation = [
        {
            "role": "system",
            "content":
                "You are an expert composer.\n\n"
                "Write similar as if an etude by composers such as: Bach, Czerny, Chopin, Liszt, Debussy, Scriabin, Rachmaninoff, Shostakovich, Bart√≥k, Paganini, Ernst, Kreutzer, Rode, Mazas, Accolay.\n"
                "When the user requests a musical composition, you must first carefully plan (don't be so generic, not always C major and 6/8 time):\n\n"
                "- Style\n"
                "- Form\n"
                "- Key (or 'atonal')\n"
                "- Modulation (if any)\n"
                "- Time Signature\n"
                "- Mood\n"
                "- Upbeat (or not)\n"
                "- Texture\n\n"
                "- Measures must add up exactly according to the time signature.\n"
                "- All voices must have the same number of measures and remain aligned bar-by-bar.\n"
                "‚úÖ Then generate the LilyPond (.ly) code inside a ```lilypond``` block.\n\n"
                "LilyPond Code Rules:\n"
                "only include a composer if specified (otherwise DO NOT include a composer)\n"
                "- Use exact pitches (no \\relative).\n"
                "- Include \\version, \\header, \\layout, and \\midi blocks.\n"
                "- Include \\score { ... } surrounding the music.\n"
                "- Use valid LilyPond pitch names (e.g., bes not Bb).\n\n"
                "- Include a tempo indication (such as a descriptive word or a numerical marking) using \\\\tempo near the beginning of the score. Choose a value that matches the character and pacing of the piece.\n"
                "- Use dynamics (e.g., \\\\p, \\\\f, \\\\mf) and expressive markings (e.g., phrasing hairpins, text expressions with \\\\markup) that support the musical shape and intention.\n"
                "- Add phrasing slurs and articulations (e.g., staccato, accents) to clarify musical expression and performance details."
                "- All staves (voices) must have the same number of measures.\n"
                "If lyrics are needed, define a variable like \\verseLyrics (do not use \\lyrics), then connect it using \\new Lyrics \\lyricsto \"voiceName\" \\verseLyrics. Always define the melody as a separate variable (e.g., melody = { ... }) before using it inside \\new Voice = \"voiceName\" { \\melody }, so lyrics can attach correctly."
                "Base the harmonic structure on the following (use it as a close guide!!):\n\n"
                "```lilypond\n" + example_lilypond + "\n```" + "\n\n"
                "NEVER output explanations, comments, or markdown outside code blocks.\n"
                "Only output pure LilyPond inside code blocks.\n\n"
                "Make the music interesting: think: movement, contrast, rests, quavers, ties, suspensions, syncopation, unity. "
                "Ensure rhythmic interest. Avoid voice doubling. Use exact pitch and valid LilyPond syntax."
                "Add syncopation, triplets, arpeggios, scalic runs, suspensions, and phrasing rests. "
                "Introduce pedal tones where appropriate. Ensure all voices contribute to the texture and maintain proper text-book voice-leading (no parallel 5ths and octaves)."
                "Ensure:\n"
                "- rhythmic contrast and interest throughout\n"
                "- expressive melodic phrasing\n"
                "- inner voices with variation (triplets, pedal tones, arpeggiation)\n"
                "- motivic unity\n"
                "- use of phrasing rests\n"
                "Always follow the formatting style used in the example score above. "
                "Each LilyPond command (e.g., \\\\version, \\\\header, variable = { ... }, \\\\score { ... }) must start on its own line. "
                "Never place multiple commands on the same line. "
                "Match the indentation and spacing style exactly."
                "Use the example score as a strict formatting template. Do not deviate from its structure or layout style. However, choose your instrumentation wisely based on the user prompt."
                "Do not include any comments (e.g., lines starting with %). Absolutely no `%` symbols should appear in the output LilyPond code. All output must be pure code only, with no comments."
        },
        {"role": "user", "content": user_prompt}
    ]

    def parse_response(full_text):
        import re
        # ‚úÖ Try matching proper Markdown code block
        match = re.search(r"```lilypond\s*(.*?)\s*```", full_text, re.DOTALL)
        if match:
            return match.group(1).strip()

        # ‚úÖ Fallback: check if it's raw LilyPond code
        if "\\version" in full_text and "\\score" in full_text:
            print("‚ö†Ô∏è Detected raw LilyPond code without code block")
            return full_text.strip()

        # ‚ùå Nothing valid found
        return None



    total_prompt_tokens = 0
    total_completion_tokens = 0
    total_tokens = 0

    lilypond_code = None
    versions = []
    all_messages = []

    for i in range(1, NUM_ITERATIONS + 1):
        if i == 1:
            messages = conversation
        else:
                if i == 2:
                    refine_prompt = (
                        "Following the original plan, add a melody over the harmony using chord tones as a base."
                        "Do not change the style, form, or key unless the plan specifies it. "
                        "Make the melody interesting and distinct compared to other voices. Think: movement, contrast, rests, quavers, ties, suspensions, syncopation, unity. "
                        "Ensure rhythmic interest. Avoid voice doubling. Use exact pitch and valid LilyPond syntax."
                    )
                elif i == 3:
                    refine_prompt = (
                        "Following the plan, enhance the inner and lower voices for greater musical and rhythmic interest. "
                        "Add syncopation, triplets, arpeggios, scalic runs, suspensions, and phrasing rests. "
                        "Introduce pedal tones where appropriate. Ensure all voices contribute to the texture and maintain proper voice-leading."
                    )
                elif i == 4:
                    refine_prompt = (
                        "Continue following the original plan. Refine the composition for musical expressiveness, rhythmic vitality, and structural clarity. "
                        "Ensure:\n"
                        "- rhythmic contrast and interest throughout\n"
                        "- expressive melodic phrasing\n"
                        "- inner voices with variation (triplets, pedal tones, arpeggiation)\n"
                        "- motivic unity\n"
                        "- use of phrasing rests\n"
                        "Ensure the LilyPond code compiles, uses exact pitch, and follows formatting rules."
                    )
                elif i == 5:
                    refine_prompt = (
                        "Finalize the composition. Confirm it matches the original plan. Make the music coherent, expressive, and formally satisfying. "
                        "Double-check that the LilyPond code includes \\version, \\header, \\layout, \\midi, and \\score { ... } and compiles correctly."
                        "Fix the score: ensure all measures add up to the correct duration, synchronize all parts bar-by-bar, and align voices so they finish together."
                    )

                messages = [
                    {
                        "role": "system",
                        "content": (
                            "You are an expert LilyPond composer and editor. When refining a composition, follow the user's original plan exactly. "
                            "Use German note names (e.g., fis, bes), exact pitch (no \\relative), and avoid parallel 5ths/8ves. "
                            "Ensure rhythmic and melodic variety, structural balance, and musical interest in all voices. "
                            "Wrap the music in a valid \\score block with \\layout and \\midi. "
                            "Output valid LilyPond code only ‚Äî no explanations or extra comments."
                        )
                    },
                    {"role": "user", "content": f"The user's original musical prompt:\n\n{user_prompt}"},
                    {"role": "user", "content": f"Here is the current LilyPond score:\n\n{lilypond_code}"},
                    {"role": "user", "content": refine_prompt}
                ]

        all_messages.append({"iteration": i, "messages": messages})

        response = log_openai_request(model=model, messages=messages, temperature=0.7)
        content = response.choices[0].message.content.strip()
        usage = response.usage
        model_used = response.model

        total_prompt_tokens += usage.prompt_tokens
        total_completion_tokens += usage.completion_tokens
        total_tokens += usage.total_tokens

        if i == 1:
            lilypond_code = parse_response(content)
            if not lilypond_code:
                raise ValueError("Failed to extract LilyPond code from model response")

        else:
            lilypond_code = content

        versions.append({
            "iteration": i,
            "lilypond": lilypond_code,
            "tokens": {
                "prompt": usage.prompt_tokens,
                "completion": usage.completion_tokens,
                "total": usage.total_tokens
            }
        })

    return {
        "final_lilypond": lilypond_code,
        "iterations": versions,
        "prompt_tokens": total_prompt_tokens,
        "completion_tokens": total_completion_tokens,
        "total_tokens": total_tokens,
        "model": model_used,
        "conversation_history": all_messages
    }



        
        
        
@app.route("/start-smart-full-generate", methods=["POST"])
def start_smart_full_generate():
    data = request.get_json()
    user_prompt = data.get("prompt")
    model = data.get("model", "gpt-4.1")
    # balance = data.get("balance", 0.0)
    user_id = data.get("user_id")  # <-- NEW
    balance = get_user_balance_value(user_id) if user_id else 0.0


    requested_filename = data.get("filename") or str(uuid.uuid4())

    if not user_prompt:
        return jsonify({"error": "Missing prompt"}), 400
    if balance < 0.99:
        return jsonify({"error": "Insufficient funds"}), 403

    filename = "".join(c for c in requested_filename if c.isalnum() or c in ("_", "-")).rstrip()
    job_id = str(uuid.uuid4())

    jobs[job_id] = {
        "status": "pending",
        "filename": filename,
        "result": None,
        "error": None
    }

    def job_runner():
        try:
            # Step 1: smart generate
            result = run_smart_generation(user_prompt, model, balance)
            
            # ‚úÖ Calculate token cost and include it in the result
            prompt_tokens = result.get("prompt_tokens", 0)
            completion_tokens = result.get("completion_tokens", 0)
            model_used = result.get("model", model)
            lilypond_code = result["final_lilypond"]
            lilypond_code = add_footer_to_lilypond(lilypond_code)  # ‚úÖ Inject footer here


            # Step 2: compile LilyPond ‚Üí PDF/MP3
            ly_path = os.path.join(OUTPUT_DIR, f"{filename}.ly")
            pdf_path = os.path.join(OUTPUT_DIR, f"{filename}.pdf")
            midi_path = os.path.join(OUTPUT_DIR, f"{filename}.midi")
            mp3_path = os.path.join(OUTPUT_DIR, f"{filename}.mp3")
            wav_path = os.path.join(OUTPUT_DIR, f"{filename}.wav")

            with open(ly_path, "w") as f:
                f.write(lilypond_code)

            try:
                subprocess.run(
                    ["lilypond", "-dignore-errors", "-o", os.path.join(OUTPUT_DIR, filename), ly_path],
                    check=True
                )
            except subprocess.CalledProcessError:
                print(f"‚ùå LilyPond compilation failed for {filename}.ly. Retrying with fallback prompts...")

                # First fallback: retry with title
                extracted_title = extract_title_from_lilypond(lilypond_code)

                def sanitize_title_for_lilypond(title):
                    return title.replace('"', '\\"').replace("\\", "\\\\")

                safe_title = sanitize_title_for_lilypond(extracted_title)
                safe_prompt_1 = f'Write a piano piece with title "{safe_title}"'
                original_title = safe_title

                try:
                    safe_result = run_smart_generation(safe_prompt_1, model, balance)
                    lilypond_code = safe_result["final_lilypond"]
                    lilypond_code = add_footer_to_lilypond(lilypond_code)

                    with open(ly_path, "w") as f:
                        f.write(lilypond_code)

                    subprocess.run(
                        ["lilypond", "-dignore-errors", "-o", os.path.join(OUTPUT_DIR, filename), ly_path],
                        check=True
                    )

                    print("‚úÖ First fallback succeeded")

                except subprocess.CalledProcessError:
                    print("‚ùå First fallback failed. Trying second fallback...")

                    safe_prompt_2 = "Write a piano piece"
                    safe_result_2 = run_smart_generation(safe_prompt_2, model, balance)
                    lilypond_code = safe_result_2["final_lilypond"]
                    
                    lilypond_code = safe_result_2["final_lilypond"]

                    if not re.search(r'title\s*=\s*"', lilypond_code):
                        lilypond_code = lilypond_code.replace(
                            '\\header {',
                            f'\\header {{\n  title = "{original_title}"',
                            1
                        )
                    else:
                        lilypond_code = re.sub(
                            r'(title\s*=\s*")[^"]*(")',
                            rf'\1{original_title}\2',
                            lilypond_code,
                            count=1
                        )

                    lilypond_code = add_footer_to_lilypond(lilypond_code)


                    with open(ly_path, "w") as f:
                        f.write(lilypond_code)

                    subprocess.run(
                        ["lilypond", "-dignore-errors", "-o", os.path.join(OUTPUT_DIR, filename), ly_path],
                        check=True
                    )

                    print("‚úÖ Second fallback succeeded")

                # # Update token accounting from fallback(s)
                # prompt_tokens += safe_result["prompt_tokens"]
                # completion_tokens += safe_result["completion_tokens"]
                # model_used = safe_result.get("model", model)



            subprocess.run([
                "fluidsynth", "-ni", SOUNDFONT_PATH, midi_path,
                "-F", wav_path, "-r", "44100"
            ], check=True)

            # subprocess.run(["ffmpeg", "-y", "-i", wav_path, mp3_path], check=True)
            subprocess.run(["ffmpeg", "-y", "-i", wav_path, "-filter:a", "volume=6dB", mp3_path], check=True)


            if os.path.exists(wav_path):
                os.remove(wav_path)
                
                
            # ‚úÖ Extract title and rename files accordingly
            title = extract_title_from_lilypond(lilypond_code)
            timestamp = int(time.time())
            safe_title = "".join(c for c in title.replace(" ", "_") if c.isalnum() or c == "_")
            final_base = f"{safe_title}_{timestamp}"

            # Final paths
            final_pdf_path = os.path.join(OUTPUT_DIR, f"{final_base}.pdf")
            final_mp3_path = os.path.join(OUTPUT_DIR, f"{final_base}.mp3")
            final_ly_path = os.path.join(OUTPUT_DIR, f"{final_base}.ly")

            # Rename files
            os.rename(pdf_path, final_pdf_path)
            os.rename(mp3_path, final_mp3_path)
            os.rename(ly_path, final_ly_path)


            

            # ‚úÖ Check if fallback was used
            conversation_history = result.get("conversation_history")
            retry_used = False

            if "safe_result" in locals():
                retry_used = True
                prompt_tokens += safe_result.get("prompt_tokens", 0)
                completion_tokens += safe_result.get("completion_tokens", 0)
                conversation_history += safe_result.get("conversation_history", [])

            if "safe_result_2" in locals():
                retry_used = True
                prompt_tokens += safe_result_2.get("prompt_tokens", 0)
                completion_tokens += safe_result_2.get("completion_tokens", 0)
                conversation_history += safe_result_2.get("conversation_history", [])


            # ‚úÖ Compute final cost
            final_cost, pricing_tier = compute_final_cost(prompt_tokens, completion_tokens, model_used)


            # ‚úÖ Save job result with cost
            jobs[job_id].update({
                "status": "completed",
                "pdf_url": f"/download/{final_base}.pdf",
                "mp3_url": f"/download/{final_base}.mp3",
                "lilypond": lilypond_code,
                "conversation_history": conversation_history,  # ‚úÖ from earlier
                "prompt_tokens": prompt_tokens,
                "completion_tokens": completion_tokens,
                "total_tokens": prompt_tokens + completion_tokens,
                "model": model_used,
                "final_cost": final_cost,
                "pricing_tier": pricing_tier,
                "title": title,
                "safe_retry_used": retry_used  # ‚úÖ new field
            })

            # ‚úÖ Deduct cost from user balance
            if user_id:
                update_balance(user_id, -final_cost)

            save_jobs_to_file()

        except Exception as e:
            jobs[job_id]["status"] = "failed"
            jobs[job_id]["error"] = str(e)
            save_jobs_to_file()




    threading.Thread(target=job_runner).start()

    return jsonify({"job_id": job_id})



def compute_final_cost(prompt_tokens, completion_tokens, model):
    if model.startswith("gpt-4.1-nano"):  # ‚úÖ safer than equality
        input_rate = 0.0001
        output_rate = 0.0004
        tier = "basic"
    else:
        input_rate = 0.002
        output_rate = 0.008
        tier = "advanced"

    openai_tax = 1.20
    profit_multiplier = 10.0
    vat = 1.20

    prompt_cost = (prompt_tokens * input_rate) / 1000
    completion_cost = (completion_tokens * output_rate) / 1000
    base_cost = prompt_cost + completion_cost

    final = base_cost * openai_tax * profit_multiplier * vat
    return round(final, 6), tier





@app.route("/clear-jobs", methods=["POST"])
def clear_jobs():
    global jobs
    jobs = {}
    save_jobs_to_file()
    return jsonify({"message": "All jobs cleared"}), 200
    
    
if __name__ == "__main__":
    # app.run(host="0.0.0.0", port=5050, debug=True) # for local Mac backend hosting
    port = int(os.environ.get("PORT", 10000)) # for Render
    app.run(host="0.0.0.0", port=port)
